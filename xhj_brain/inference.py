import torch
from torch import nn
import numpy as np
import joblib
from word2vec import v2v
from model import MLP256, MLP512

def run_inf(user_lst):

    net = MLP256()
    clone = net
    clone.load_state_dict(torch.load('./data/mlp.params'))
    print('---> mlp.params (generated by train.py) <--- loading succeeded.')
    clone.eval()
    testx = np.array([user_lst])

    testx_3 = v2v([testx[0][3]])

    # @@@@@@@@@@@@@@@@@@@@@@@@
    user_lst[3] = testx_3[0]
    testx = np.array([user_lst])
    testx = testx.astype(np.float32)
    user_scal = joblib.load('./data/user_scaler.model')
    print('---> user_scaler.model (generated by preprocess.py) <--- loading succeeded.')
    testx = user_scal.transform(testx)
    x = torch.tensor(testx)
    y = clone(x)
    ########################################################
    net2 = nn.Sequential(nn.Linear(10, 1),)

    def init_weights(m):
        if type(m) == nn.Linear:
            nn.init.ones_(m.weight)
            nn.init.ones_(m.bias)
    net2.apply(init_weights)
    # with torch.no_grad():
    #     net2[0].weight[0][0] = net2[0].weight[0][0]/10
    # print(net2[0].weight)
    # print(net2[0].bias)
    testy = net2(y)
    y = testy.detach().numpy()[0][0]
    #print('user -----> house : {}'.format(y))
    return str(y)

if __name__ == "__main__":
    user_lst = [3000, 4500, 3, '恒大绿洲']
    run_inf(user_lst)
